# Git_help

```git checkout -f``` Очистка всех незакомментированных изменений 

```git config —list —show-origin``` просмотр конфига

```git commit --amend -m "New commit message"``` обновление сообщения в коммите

```git reset HEAD~``` Отменить последний коммит, но сохранить изменения

```merge vs rebase```
Чтобы понять когда нужно использовать merge и rebase, нужно (внезапно) понять как они работают и что делают.

Merge - это средство интеграции изменений из двух (и даже более) последовательностей изменений. Когда вы хотите сказать - я беру изменения из своей ветки и из другой, и совмещаю их друг с другом - вам нужно делать merge. Слияние не изменяет имеющуюся историю изменений, а наоборот, продолжает её. Создавая мёрж-коммит вы как бы говорите всем - "я совместил изменения из этих двух веток, все кому нужны изменения из этих обоих веток ОДНОВРЕМЕННО (например, из ветки feature_buy_button и ветки master) - можете взять этот коммит". Вы говорите это в том числе и самому себе, когда подмёрживаете мастер себе в ветку разработки - после мёржа вы знаете что все ранее сделанные изменения в вашей ветке и мастер-ветке теперь живут вместе.

Rebase - это средство автоматического или полуавтоматического редактирования истории изменений. Вернее даже не редактирования, нет. Это средство СОЗДАНИЯ новой последовательности изменений на основе имеющейся. А теперь давайте подумаем, когда это бывает нужно:
вы упороли в каком-то коммите, сделанном в начале недели, оставили в правках пароль/приватный ключ и т.п., но не успели залить ветку в публичное место. Хочется пароль удалить, но все остальные коммиты (которых уже 20 штук набралось с тех пор) оставить как есть.
вас попросили убрать из ветки некоторые обособленные изменения. Вы понимаете, что вполне могли бы выбросить пару коммитов как раз с этими изменениями;
у вас в компании стандарт на формат коммит-месседжей, но вы сделали пару неудачных сообщений в вашей ветке и вам нужно их поправить;
вам нужно поправить имя/почту в ваших коммитах.

В то же время, мы стараемся не использовать и даже вовсе запрещаем ребейз, если история стала коллективной. Что это значит? Ну например:
от бранча был сделан ещё один бранч и над ним работает кто-то другой;
изменения в бранче начали проходить код-ревью (т.к. комментарии к коду обычно связаны с коммитами, формирование новой истории приводит к "отваливанию" комментариев).





```git stash```
Прятанье своих трудов
Чтобы продемонстрировать, как это работает, предположим, что вы идёте к своему проекту и начинаете работать над парой файлов и, возможно, добавляете в индекс одно из изменений. Если вы выполните git status, вы увидите грязное состояние проекта:

$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#      modified:   index.html
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#
#      modified:   lib/simplegit.rb
#
Теперь вы хотите поменять ветку, но не хотите делать коммит с тем, над чем вы ещё работаете; тогда вы прячете эти изменения. Чтобы создать новую "заначку", выполните git stash:

$ git stash
Saved working directory and index state \
  "WIP on master: 049d078 added the index file"
HEAD is now at 049d078 added the index file
(To restore them type "git stash apply")
Ваш рабочий каталог чист:

$ git status
# On branch master
nothing to commit, working directory clean
В данный момент вы легко можете переключить ветки и поработать где-то ещё; ваши изменения сохранены в стеке. Чтобы посмотреть, что у вас есть припрятанного, используйте git stash list:

$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051... Revert "added file_size"
stash@{2}: WIP on master: 21d80a5... added number to log
В нашем случае две "заначки" были сделаны ранее, так что у вас теперь три разных припрятанных работы. Вы можете снова применить ту, которую только что спрятали, с помощью команды, показанной в справке в выводе первоначальной команды stash: git stash apply. Если вы хотите применить одну из старых заначек, можете сделать это, указав её имя так: git stash apply stash@{2}. Если не указывать ничего, Git будет подразумевать, что вы хотите применить последнюю спрятанную работу:

$ git stash apply
# On branch master
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#
#      modified:   index.html
#      modified:   lib/simplegit.rb
#
Как видите, Git восстановил изменения в файлах, которые вы отменили, когда использовали команду stash. В нашем случае у вас был чистый рабочий каталог, когда вы восстанавливали спрятанные изменения, и к тому же вы делали это на той же ветке, на которой находились во время прятанья. Но наличие чистого рабочего каталога и применение на той же ветке не обязательны для git stash apply. Вы можете спрятать изменения на одной ветке, переключиться позже на другую ветку и попытаться восстановить изменения. У вас в рабочем каталоге также могут быть изменённые и недокоммиченные файлы во время применения спрятанного — Git выдаст вам конфликты слияния, если что-то уже не может быть применено чисто.

Изменения в файлах были восстановлены, но файлы в индексе — нет. Чтобы добиться такого, необходимо выполнить команду git stash apply с опцией --index, тогда команда попытается применить изменения в индексе. Если бы вы выполнили команду так, а не как раньше, то получили бы исходное состояние:

$ git stash apply --index
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#      modified:   index.html
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#
#      modified:   lib/simplegit.rb
#
Всё, что делает опция apply — это пытается применить спрятанную работу — то, что вы спрятали, всё ещё будет находиться в стеке. Чтобы удалить спрятанное, выполните git stash drop с именем "заначки", которую нужно удалить:

$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051... Revert "added file_size"
stash@{2}: WIP on master: 21d80a5... added number to log
$ git stash drop stash@{0}
Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)
Также можно выполнить git stash pop, чтобы применить спрятанные изменения и сразу же удалить их из стека.
